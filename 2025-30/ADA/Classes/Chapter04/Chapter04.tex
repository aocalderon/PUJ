\documentclass{beamer}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tcolorbox}
\usepackage{amsmath, esint}
\usepackage{tikz}
\usetikzlibrary{backgrounds, positioning, arrows, scopes, shapes, shapes.misc, shapes.multipart}
\tikzset{
    cross/.style={cross out, draw=black, minimum size=2*(#1-\pgflinewidth), inner sep=0pt, outer sep=0pt},
    cross/.default={10pt},
    split/.style={rectangle split, rectangle split parts=7, draw, inner sep=0ex, rectangle split horizontal, minimum size=4ex},
    textstyle/.style={text height=1.5ex, text depth=.25ex}
}

\usepackage{amsthm}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}


\hypersetup{colorlinks,linkcolor=,urlcolor=blue}
\usepackage{xcolor} 
\definecolor{LightGray}{gray}{0.975}

%\usetheme{Warsaw}
\usefonttheme{serif} 

\title[L4 Quicksort]{Introduction to Algorithms \\ Lecture 4: Quicksort}
\author{Prof. Charles E. Leiserson and Prof. Erik Demaine \\ Massachusetts Institute of Technology}
\date{\today}

\setbeamertemplate{navigation symbols}{}%remove navigation symbols

\defbeamertemplate*{footline}{shadow theme}{%
    \leavevmode%
    \hbox{
        \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm plus1fil,rightskip=.3cm]{author in head/foot}%
            \usebeamerfont{author in head/foot} Introduction to Algorithms: \hfill \insertshorttitle
        \end{beamercolorbox}%
        \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm,rightskip=.3cm plus1fil]{title in head/foot}%
            \usebeamerfont{title in head/foot} \hfill \insertframenumber\,/\,\inserttotalframenumber%
        \end{beamercolorbox}
    }%
    \vskip0pt%
}

\AtBeginSection[]{
    \begin{frame}<beamer>
    \frametitle{Plan}
    \tableofcontents[currentsection]
    \end{frame}
}

\begin{document}

\frame{\titlepage}

\begin{frame}{Introduction to Algorithms}
    \centering
    \includegraphics[width=0.45\textwidth]{figures/book_cover.jpg} \\
    \vspace{5mm}{
        \tiny
        Content has been extracted from \textit{Introduction to Algorithms}, Fourth Edition, by Cormen, Leiserson, Rivest, and Stein. MIT Press. 2022.\\
        Visit \url{https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/}.\\
        Original slides from \textit{Introduction to Algorithms 6.046J/18.401J}, Fall 2005 Class by Prof. Charles Leiserson and Prof. Erik Demaine. MIT OpenCourseWare Initiative available at \url{https://ocw.mit.edu/courses/6-046j-introduction-to-algorithms-sma-5503-fall-2005/}.\\
    }
\end{frame}

\section{Description of Quicksort}

\begin{frame}{Quicksort}
    \begin{itemize}
            \item Proposed by C.A.R. Hoare in 1962. \pause
            \item Divide-and-conquer algorithm. \pause
            \item Sorts `in place' (like insertion sort, but not like merge sort). \pause
            \item Very practical (with tuning).
    \end{itemize}
\end{frame}

\section{Divide \& Conquer}

\begin{frame}{Divide and Conquer}
    Quicksort an $n$-element array:
    \begin{enumerate}
        \item \textbf{\Large Divide:} Partition the array into two subarrays around a \textbf{pivot} $x$ such that elements in lower subarray $\leq x \leq$ elements in upper subarray. \pause
            \begin{tikzpicture}
                \tikzstyle{bplus}=[
                    rectangle split,
                    rectangle split horizontal,
                    rectangle split ignore empty parts
                ]
                \tikzset{every node/.style={bplus}}

                \node[draw, text width=4cm, align=center] (myNode) {
                    \LARGE $\leq x$
                    \nodepart[text width=1cm, align=center]{two} \LARGE $x$
                    \nodepart[text width=4cm, align=center]{three} \LARGE $> x$
                };
            \end{tikzpicture} \pause
        \item \textbf{\Large Conquer:} Recursively sort the two subarrays. \pause
        \item \textbf{\Large Combine:} Trivial. \pause
    \end{enumerate}
    \begin{alertblock}{Key:}
        Linear-time partitioning subroutine.
    \end{alertblock}
\end{frame}

\section{Partitioning}

\begin{frame}{Partitioning Subroutine}
    \begin{minipage}{0.58\textwidth}
        \begin{algorithm}[H]
            \begin{algorithmic}[1]
                %\State \hrulefill
                \Procedure{\textsc{Partition}}{$A$, $p$, $r$}
                    \State $x \leftarrow A[r]$
                    \State $i \leftarrow p - 1$
                    \For{$j \leftarrow p$ \textbf{to} $r - 1$}
                        \If{$A[j] \leq x$}
                            \State $i \leftarrow i + 1$
                            \State exchange $A[i] \leftrightarrow A[j]$
                        \EndIf
                    \EndFor
                    \State exchange $A[i + 1] \leftrightarrow A[r]$
                    \State \Return $i + 1$
                \EndProcedure
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.38\textwidth} \pause
        \begin{alertblock}{Running time:}
            $O(n)$ for $n$ elements.
        \end{alertblock}
        \vspace{4.5cm}
    \end{minipage}
    \pause
    \begin{itemize}
     \item[ ] \textbf{Invariants:}
    \end{itemize}
    \centering
    \begin{tikzpicture}
        \tikzstyle{bplus}=[
            rectangle split,
            rectangle split horizontal,
            rectangle split ignore empty parts
        ]
        \tikzset{every node/.style={bplus}}

        \node[draw, text width=3cm, align=center] (myNode) {
            \LARGE $\leq x$
            \nodepart[text width=3cm, align=center]{two} \LARGE $> x$
            \nodepart[text width=2cm, align=center]{three} \LARGE $?$
            \nodepart[text width=0.5cm, align=center]{four} \LARGE $x$
        };
        \node at (-4.40, -0.6) {\textit{p}};
        \node at (-1.80, -0.6) {\textit{i}};
        \node at ( 2.10, -0.6) {\textit{j}};
        \node at ( 4.40, -0.6) {\textit{r}};
    \end{tikzpicture}
\end{frame}

\begin{frame}{Loop Invariants: Definition}
    \begin{center}
        \begin{tikzpicture}
            \tikzstyle{bplus}=[
                rectangle split,
                rectangle split horizontal,
                rectangle split ignore empty parts
            ]
            \tikzset{every node/.style={bplus}}

            \node[draw, text width=2.5cm, align=center] (myNode) {
                $\leq x$
                \nodepart[text width=2.5cm, align=center]{two} $> x$
                \nodepart[text width=1.5cm, align=center]{three} $?$
                \nodepart[text width=0.3cm, align=center]{four} $x$
            };
            \node at (-3.70, -0.5) {\textit{p}};
            \node at (-1.40, -0.5) {\textit{i}};
            \node at ( 1.80, -0.5) {\textit{j}};
            \node at ( 3.70, -0.5) {\textit{r}};
        \end{tikzpicture}
    \end{center}
    At the beginning of each iteration of the loop (lines 4--9), for any array index $k$:
    \begin{enumerate}
        \item \textbf{Low side:} If $p \leq k \leq i$, then $A[k] \leq x$.
        \item \textbf{High side:} If $i+1 \leq k \leq j-1$, then $A[k] \geq x$.
        \item \textbf{Pivot:} If $k = r$, then $A[k] = x$.
    \end{enumerate}
    These conditions define the partitioning into three regions:
    \begin{itemize}
        \item Elements $\leq x$ (low side).
        \item Elements $> x$ (high side).
        \item The pivot element.
    \end{itemize}
\end{frame}

\begin{frame}{Initialization and Maintenance}
    \textbf{Initialization:}
    \begin{itemize}
        \item Before first iteration: $i = p-1$, $j = p$.
        \item No values yet examined, so invariants hold trivially.
        \item Line 2 ensures pivot condition (3) holds.
    \end{itemize}
    \textbf{Maintenance:}
    \begin{itemize}
        \item If $A[j] > x$: only increment $j$, preserving high side property.
        \item If $A[j] \leq x$: increment $i$, swap $A[i]$ and $A[j]$, then increment $j$.
        \item Swapping ensures $A[i] \leq x$ and $A[i+1] \dots A[j-1] > x$.
    \end{itemize}
\end{frame}

\begin{frame}{Termination and Correctness}
    \textbf{Termination:}
    \begin{itemize}
        \item Loop ends when $j = r$.
        \item The unexamined subarray $A[j \dots r-1]$ is empty.
        \item All entries are in one of the three invariant regions.
    \end{itemize}
    \textbf{Correctness:}
    \begin{itemize}
        \item Array is partitioned into:
        \begin{enumerate}
            \item Elements $\leq x$ (low side).
            \item Elements $> x$ (high side).
        \end{enumerate}
        \item Pivot is placed immediately after the low side.
    \end{itemize}
\end{frame}

\begin{frame}{Regions in the Partition Procedure}
    \centering
    \includegraphics[width=\textwidth, trim={5.75cm 23.00cm 6.75cm 2.50cm}, clip]{figures/exchange}
\end{frame}

\begin{frame}{Handling Cases During Partition}
    \centering
    \includegraphics[width=0.85\textwidth, trim={5.75cm 12.00cm 5.75cm 6.75cm}, clip]{figures/exchange}
\end{frame}

\begin{frame}{Example of partitioning}
    \vspace{-1mm}
    \centering
    \begin{tikzpicture}
        \node[align=center] at (6, 2) {
            \includegraphics[width=0.37\textwidth, trim={6.00cm 13.00cm 10.00cm 2.50cm}, clip]{figures/example}
        };
        \only<1>{\fill[white] (3.95, -2.00) rectangle (8, 5.45);}
        \only<2>{\fill[white] (3.95, -2.00) rectangle (8, 4.45);}
        \only<3>{\fill[white] (3.95, -2.00) rectangle (8, 3.45);}
        \only<4>{\fill[white] (3.95, -2.00) rectangle (8, 2.50);}
        \only<5>{\fill[white] (3.95, -2.00) rectangle (8, 1.55);}
        \only<6>{\fill[white] (3.95, -2.00) rectangle (8, 0.70);}
        \only<7>{\fill[white] (3.95, -2.00) rectangle (8, -0.20);}
        \only<8>{\fill[white] (3.95, -2.00) rectangle (8, -1.20);}
        \only<9>{\fill[white] (3.95, -2.00) rectangle (8, -2.00);}
    \end{tikzpicture}
\end{frame}

% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_5}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_6}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_7}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_8}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_9}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_10}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_11}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_12}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_13}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_14}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_15}
% \end{frame}
% \begin{frame}{Example of partitioning}
%     \centering
%     \includegraphics[width=\textwidth, trim={2.75cm 1.80cm 2.75cm 5.00cm}, clip]{pages/lec4_16}
% \end{frame}

\begin{frame}{Pseudocode for Quicksort}
        \begin{algorithm}[H]
            \begin{algorithmic}[1]
                \Procedure{\textsc{Quicksort}}{$A$, $p$, $r$}
                    \If{$p < r$}
                        \State $q \leftarrow$ \textsc{Partition}($A$,$p$, $r$)
                        \State \textsc{Quicksort}($A$, $p$, $q - 1$)
                        \State \textsc{Quicksort}($A$, $q + 1$, $r$)
                    \EndIf
                \EndProcedure
            \end{algorithmic}
        \end{algorithm}
        \pause
        \begin{alertblock}{Initial call:}
            \textsc{Quicksort}($A$, $1$, $n$)
        \end{alertblock}
\end{frame}

\section{Worst-case Analysis}

\begin{frame}{Performance of Quicksort}
    \begin{itemize}
        \item Assume all input elements are distinct. \pause
        \item In practice, there are better partitioning algorithms for when duplicate input elements may exist. \pause
        \item Let $T(n) =$ worst-case running time on an array of $n$ elements.
    \end{itemize}
\end{frame}

\begin{frame}{Worst-case of Quicksort}
    \begin{itemize}
        \item Input sorted or reverse sorted. \pause
        \item Partition around min or max element. \pause
        \item One side of partition always has no elements. \pause
    \end{itemize}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + \Theta(n) \\
                    =& \Theta(1) + T(n - 1) + \Theta(n) \\
                    =& T(n - 1) + \Theta(n) \\
                    =& \Theta(n^2)
        \end{split}
    \end{equation*}
    \pause
    \centering
    \textcolor{red}{\textbf{Arithmetic Series!}}
\end{frame}

\begin{frame}{Worst-case Recursion Tree}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + cn \\
        \end{split}
    \end{equation*}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.80cm 0.50cm 5.25cm}, clip]{pages/lec4_20}
\end{frame}

\begin{frame}{Worst-case Recursion Tree}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + cn \\
        \end{split}
    \end{equation*}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.80cm 0.50cm 5.25cm}, clip]{pages/lec4_21}
\end{frame}
\begin{frame}{Worst-case Recursion Tree}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + cn \\
        \end{split}
    \end{equation*}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.80cm 0.50cm 5.25cm}, clip]{pages/lec4_22}
\end{frame}
\begin{frame}{Worst-case Recursion Tree}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + cn \\
        \end{split}
    \end{equation*}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.80cm 0.50cm 5.25cm}, clip]{pages/lec4_23}
\end{frame}
\begin{frame}{Worst-case Recursion Tree}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + cn \\
        \end{split}
    \end{equation*}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.80cm 0.50cm 5.25cm}, clip]{pages/lec4_24}
\end{frame}
\begin{frame}{Worst-case Recursion Tree}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + cn \\
        \end{split}
    \end{equation*}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.80cm 0.50cm 5.25cm}, clip]{pages/lec4_25}
\end{frame}
\begin{frame}{Worst-case Recursion Tree}
    \begin{equation*}
        \begin{split}
            T(n) =& T(0) + T(n - 1) + cn \\
        \end{split}
    \end{equation*}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.80cm 0.50cm 5.25cm}, clip]{pages/lec4_26}
\end{frame}

\section{Intuition}

\begin{frame}{Best-case Performance}{For intuition only!}
    If we're lucky, \textsc{Partition} splits the array evenly: \pause
    \begin{equation*}
        \begin{split}
            T(n) =& 2T\left(\frac{n}{2}\right) + \Theta(n) \\
                 =& \Theta(n \lg n) \\
        \end{split}
    \end{equation*} \pause
    \begin{itemize}
        \item Same as merge-sort. \pause
        \item Which case is this? \pause Case 2.
    \end{itemize} \pause

    What if the split is always $\frac{1}{10}:\frac{9}{10}$? \pause
    \begin{equation*}
        \begin{split}
            T(n) =& T\left(\frac{1}{10} n \right) + T\left(\frac{9}{10} n \right) + \Theta(n) \\
        \end{split}
    \end{equation*}
    What is the solution to this recurrence?
\end{frame}

\begin{frame}{Performance of ``Almost-best'' Case}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.50cm 1.00cm 4.25cm}, clip]{pages/lec4_28}
\end{frame}
\begin{frame}{Performance of ``Almost-best'' Case}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.50cm 1.00cm 4.25cm}, clip]{pages/lec4_29}
\end{frame}
\begin{frame}{Performance of ``Almost-best'' Case}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.50cm 1.00cm 4.25cm}, clip]{pages/lec4_30}
\end{frame}
\begin{frame}{Performance of ``Almost-best'' Case}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.50cm 1.00cm 4.25cm}, clip]{pages/lec4_31}
\end{frame}
\begin{frame}{Performance of ``Almost-best'' Case}
    \centering
    \includegraphics[width=\textwidth, trim={1.00cm 1.50cm 1.00cm 4.25cm}, clip]{pages/lec4_32}
\end{frame}

\begin{frame}{More Intuition}
    Suppose we alternate lucky, unlucky, lucky, unlucky, lucky, ...
    \begin{equation*}
        \begin{split}
            L(n) =& 2U\left(\frac{n}{2}\right) + \Theta(n) \text{\hspace{17mm} \textcolor{red}{\textit{lucky}} } \\
            U(n) =& L\left(n - 1\right) + \Theta(n) \text{\hspace{15mm} \textcolor{red}{\textit{unlucky}} } \\
        \end{split}
    \end{equation*}
    Solving:
    \begin{equation*}
        \begin{split}
            L(n) =& 2\left(L\left(\frac{n}{2} - 1 \right) + \Theta(\frac{n}{2})\right) + \Theta(n) \\
                 =& 2L\left(\frac{n}{2} - 1 \right) + \Theta(n) \\
                 =& \Theta(n \lg n) \text{\hspace{15mm} \textbf{\textcolor{red}{Lucky!}}}
        \end{split}
    \end{equation*}
    How can we make sure we are usually lucky?
\end{frame}

\section{Randomized Quicksort}

\begin{frame}{Randomized Quicksort}
    \begin{alertblock}{\textsc{Idea:}}
        Partition around a \textbf{random} element.
    \end{alertblock}
    \begin{itemize}
        \item Running time is independent of the input order.
        \item No assumptions need to be made about the input distribution.
        \item No specific input elicits the worst-case behavior.
        \item The worst case is determined only by the output of a random-number generator.
    \end{itemize}
\end{frame}

\section{Analysis}

\begin{frame}{Randomized Quicksort Analysis}
    Let $T(n) = $ the random variable for the running time of randomized quicksort on an input of size $n$, assuming random numbers are independent.
    $$
        \text{For } k = 0, 1, \ldots, n - 1\text{, define the \textcolor{red}{\textbf{indicator random variable}.}}
    $$

    $$
        X_k = \left\{
            \begin{array}{l l}
                \text{ 1 \text{\hspace{3mm}}} & \text{ if \textsc{Partition} generates a } k: n-k-1 \text{ split,} \\
                \text{ 0 \text{\hspace{3mm}}} & \text{ otherwise.} \\
            \end{array}
        \right.
    $$
    \pause
    $E[X_k] = 0 \cdot Pr\{X_k = 0\} + 1 \cdot Pr\{X_k = 1\} = Pr\{X_k = 1\} = \frac{1}{n}$, since all splits are equally likely, assuming element are distinct.
\end{frame}

\begin{frame}{Analysis (Cont.)}
    $$
        T(n) = \left\{
            \begin{array}{l l}
                T(0) + T(n - 1) + \Theta(n) & \text{if } 0 : n - 1 \text{ split,} \\
                T(1) + T(n - 2) + \Theta(n) & \text{if } 1 : n - 2 \text{ split,} \\
                \text{\hspace{5mm}} \vdots & \\
                T(n - 1) + T(0) + \Theta(n) & \text{if } n - 1 : 0 \text{ split.} \\
            \end{array}
        \right.
    $$

    \vspace{10mm}
    \centering
    \Large
    $= \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n))$
\end{frame}

\section{Expected Running Time}

\begin{frame}{Calculating expectation}{Take expectations of both sides.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Calculating expectation}{Linearity of expectation.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E\left[ X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Calculating expectation}{Independence of $X_k$ from other random choices.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E\left[ X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E[X_k] \cdot E[T(k) + T(n - k - 1) + \Theta(n)] \\
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Calculating expectation}{$E[X_k] = \frac{1}{n}$.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E\left[ X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E[X_k] \cdot E[T(k) + T(n - k - 1) + \Theta(n)] \\
        &= \frac{1}{n} \sum\limits_{k=0}^{n-1}  E[T(k) + T(n - k - 1) + \Theta(n)] \\
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Calculating expectation}{Linearity of expectation.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E\left[ X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E[X_k] \cdot E[T(k) + T(n - k - 1) + \Theta(n)] \\
        &= \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(k)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(n - k - 1)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} \Theta(n) \\
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Calculating expectation}{Summations have identical terms.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E\left[ X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E[X_k] \cdot E[T(k) + T(n - k - 1) + \Theta(n)] \\
        &= \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(k)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(n - k - 1)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} \Theta(n) \\
        &= \frac{2}{n}\sum\limits_{k=0}^{n-1} E[T(k)] + \frac{1}{n}\sum\limits_{k=0}^{n-1} \Theta(n)
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Calculating expectation}{$n\cdot\Theta(n)=\Theta(n^2)$.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E\left[ X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E[X_k] \cdot E[T(k) + T(n - k - 1) + \Theta(n)] \\
        &= \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(k)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(n - k - 1)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} \Theta(n) \\
        &= \frac{2}{n}\sum\limits_{k=0}^{n-1} E[T(k)] + \frac{1}{n}\Theta(n^2)
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Calculating expectation}{Sum up.}
    \begin{equation*}
        \begin{split}
E[T(n)] &= E\left[ \sum\limits_{k=0}^{n-1} X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E\left[ X_k(T(k) + T(n - k - 1) + \Theta(n)) \right] \\
        &= \sum\limits_{k=0}^{n-1} E[X_k] \cdot E[T(k) + T(n - k - 1) + \Theta(n)] \\
        &= \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(k)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} E[T(n - k - 1)] +
           \frac{1}{n}\sum\limits_{k=0}^{n-1} \Theta(n) \\
        &= \frac{2}{n}\sum\limits_{k=0}^{n-1} E[T(k)] + \Theta(n)
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Hairy recurrence}
    \begin{equation*}
        \begin{split}
        E[T(n)] &= \frac{2}{n}\sum\limits_{k=2}^{n-1} E[T(k)] + \Theta(n) \\
        \end{split}
    \end{equation*}
    (The $k = 0$, $1$ terms can be absorbed in the $\Theta(n)$.)
    \begin{alertblock}{\textcolor{red}{\textbf{Prove:}}}
        $E[T(n)] \leq a n \lg n$ for constant $a > 0$.
    \end{alertblock}
    \begin{itemize}
        \item Choose a large enough so that $a n \lg n$ dominates $E[T(n)]$ for sufficiently small $n \geq 2$.
    \end{itemize}
    \begin{alertblock}{\textcolor{red}{\textbf{Use fact:}}}
        $\sum\limits_{k=2}^{n-1} k \lg k \leq \frac{1}{2} n^2 \lg n - \frac{1}{8} n^2$ (exercise).
    \end{alertblock}
\end{frame}

\begin{frame}{Substitution method}{Substitute inductive hypothesis.}
    \begin{equation*}
        \begin{split}
        E[T(n)] &\leq \frac{2}{n}\sum\limits_{k=2}^{n-1} a k \lg k + \Theta(n) \\
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Substitution method}{Use fact.}
    \begin{equation*}
        \begin{split}
        E[T(n)] &\leq \frac{2}{n}\sum\limits_{k=2}^{n-1} a k \lg k + \Theta(n) \\
                &\leq \frac{2a}{n} \left( \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2 \right) + \Theta(n) \\
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Substitution method}
    \begin{equation*}
        \begin{split}
        E[T(n)] &\leq \frac{2}{n}\sum\limits_{k=2}^{n-1} a k \lg k + \Theta(n) \\
                &\leq \frac{2a}{n} \left( \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2 \right) + \Theta(n) \\
                &= a n \lg n - \left( \frac{an}{4} - \Theta(n) \right) \\
                &\leq a n \lg n \text{,} \\
                &\text{\hspace{10mm} if $a$ is chosen large enough so that} \\
                &\text{\hspace{10mm} $\frac{an}{4}$ dominates the $\Theta(n)$.}
        \end{split}
    \end{equation*}
\end{frame}

\begin{frame}{Quicksort in practice}
    \begin{itemize}
        \item Quicksort is a great general-purpose sorting algorithm. \pause
        \item Quicksort is typically over twice as fast as merge sort. \pause
        \item Quicksort can benefit substantially from \textcolor{red}{\textbf{code tuning}}. \pause
        \item Quicksort behaves well even with caching and virtual memory.
    \end{itemize}
\end{frame}

\begin{frame}{}
    \centering
    \Huge End of Lecture 4.
\end{frame}

\section*{Takeaways}

% Tim Duncan's Top 5 Fundamental Takeaways of Today's Class
\begin{frame}{TDT5FTOTC}
    \centering
    \includegraphics[width=0.75\textwidth]{figures/tim.png}
\end{frame}

\begin{frame}{Top 5 Fundamental Takeaways}
    \small
    \begin{enumerate} \pause
        \item[5] \textbf{Quicksort is a Divide-and-Conquer Algorithm} – It recursively partitions an array around a pivot and sorts the subarrays efficiently.\pause

        \item[4] \textbf{Partitioning is the Core of Quicksort} – The partitioning step ensures elements are correctly placed around the pivot in $O(n)$ time.\pause

        \item[3] \textbf{Best-case and Worst-case Analysis} – Quicksort runs in $O(n \log n)$ in the best case but can degrade to $O(n^2)$ if poorly partitioned.\pause

        \item[2] \textbf{Randomized Quicksort Helps Avoid Worst-case Behavior} – Choosing a random pivot prevents consistently bad splits and ensures an expected $O(n \log n)$ runtime.\pause

        \item[1] \textbf{Quicksort is Highly Efficient in Practice} – It outperforms merge sort in most cases and benefits from hardware optimizations.

    \end{enumerate}
\end{frame}

\begin{frame}{Introduction to Algorithms}
    \centering
    \includegraphics[width=0.45\textwidth]{figures/book_cover.jpg} \\
    \vspace{5mm}{
        \tiny
        Content has been extracted from \textit{Introduction to Algorithms}, Fourth Edition, by Cormen, Leiserson, Rivest, and Stein. MIT Press. 2022.\\
        Visit \url{https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/}.\\
        Original slides from \textit{Introduction to Algorithms 6.046J/18.401J}, Fall 2005 Class by Prof. Charles Leiserson and Prof. Erik Demaine. MIT OpenCourseWare Initiative available at \url{https://ocw.mit.edu/courses/6-046j-introduction-to-algorithms-sma-5503-fall-2005/}.\\
    }
\end{frame}

\end{document}
