\documentclass{article}

\usepackage[left=2cm, top=3cm, right=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{wasysym}
\usepackage[colorlinks]{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{svg}
\usepackage{minted}
\usepackage{xcolor}
\definecolor{LightGray}{gray}{0.975}

%setup new colors
\hypersetup{
linkcolor=blue,
citecolor=cyan,
urlcolor=blue
}

%opening
\title{Lab 01: Analyzing Linear and Logarithmic-Time Algorithms for Unimodal Search}
\author{Andrés Oswaldo Calderón Romero}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
The goal of this lab is to deepen your understanding of algorithmic design and analysis by studying the \textit{unimodal search} problem, a classic example that illustrates the trade-offs between linear and logarithmic-time approaches. You will begin by developing a straightforward $O(n)$ algorithm that performs a single linear scan to locate the peak element in a unimodal array. This serves as a baseline for analyzing the performance of more sophisticated techniques.

Next, you will design and implement an optimized $O(\log n)$ algorithm based on a divide-and-conquer strategy. Beyond implementation, you will formally prove the correctness of your approach and evaluate its efficiency through empirical experiments. By comparing both solutions, you will gain insight into asymptotic complexity, practical performance differences, and the importance of algorithmic choice when solving real-world problems.


\section{Problem Definition}
An array $A[1 \ldots n]$ is \textbf{unimodal} (also known as \textbf{bitonic}) if it consists of an increasing sequence followed by a decreasing sequence. More precisely, there exists an index $m \in \{1, 2, \ldots, n\}$ such that:

$$
A[1] < A[2] < \dots < A[m]
$$

and

$$
A[m] > A[m+1] > \dots > A[n],
$$

where $A[m]$ is the \textbf{peak} of the array. This means that the values strictly increase up to $m$ and then strictly decrease afterward. The task of \textbf{unimodal search} is to efficiently find the peak element $A[m]$ in such an array.

In particular, $A[m]$ is the maximum element and the unique ``locally maximum'' element, meaning it is surrounded by smaller elements, specifically $A[m - 1]$ and $A[m + 1]$.

\subsection{Problem to Solve}\label{sec:problem}
\begin{enumerate}
    \item Implement a naive algorithm to compute the maximum element of a unimodal input array $A[1 \ldots n]$ in $O(n)$ time. This algorithm should perform a single linear pass over the array to find the maximum.
    \item Design and implement an algorithm to compute the maximum element of a unimodal input array $A[1 \ldots n]$ in $O(\log n)$ time. Prove the correctness of your algorithm and establish a bound on its running time.
    \item Empirically compare both implementations to evaluate the performance of each algorithm.
    \item Submit your findings in a well-structured report, including the code used and any additional relevant materials.
\end{enumerate}

\section{What We Expect}
You must submit a well-structured report in \textbf{PDF} format, along with the code for your implementations and any additional materials used to solve the problem, packaged in a single \textbf{ZIP} file. The submission must be completed by \textbf{August 14, 2025}, using the link that will be available on the Brightspace\texttrademark\ platform.

\section{Useful Resources}
The problem was initially stated in Problem Set 1 (Problem 1-3), and a solution for item 2 in Section \ref{sec:problem} is provided in the Problem Set 1 Solutions available through MIT OpenCourseWare, taught by Prof. Leiserson and Prof. Demaine \cite{leiserson1:2005, leiserson2:2005}. Please attempt to solve the problem on your own first and then verify your solution with the one provided. However, if you find yourself stuck after a reasonable amount of time, you may consult the solution as a last resort.

Similarly, plenty of code can be found on the Internet or generated by AI, but—as mentioned earlier—make an honest attempt on your own before seeking external sources. This webpage \cite{gfg:2023} may also be a useful resource if you find yourself struggling during the implementation.

\bibliography{refs}
\bibliographystyle{ieeetr}

\end{document}
