\documentclass[letter, 12pt]{article}

\usepackage{amsmath, amssymb, hyperref, graphicx, geometry}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=blue,
  citecolor=blue,
  pdfpagemode=FullScreen
}

\geometry{margin=2.5cm}

\title{Guías de Estudio para el 3er Examen}
\author{Andrés Calderón, PhD.}
\date{\today}

\begin{document}
    \maketitle

    \section{Lección 1: Fundamentos de Problemas Polinomiales y Superpolinomiales}

    En el ámbito del análisis de algoritmos, las complejidades de tiempo ``polinomial'' y ``superpolinomial'' representan categorías distintas de eficiencia algorítmica. La complejidad de tiempo polinomial, denotada como $O(n^k)$ para alguna constante $k$, indica algoritmos que pueden completar sus tareas en un tiempo razonable a medida que aumenta el tamaño de la entrada ($n$). Por el contrario, la complejidad de tiempo superpolinomial, que incluye tiempos exponenciales ($O(2^n)$), se considera ineficiente, ya que el tiempo requerido para ejecutar estos algoritmos crece exponencialmente con el tamaño de la entrada.

    \subsection{Complejidad de Tiempo Polinomial}

    \subsubsection{Definición:}
    Un algoritmo se considera de tiempo polinomial si su tiempo de ejecución está acotado por una función polinomial del tamaño de la entrada.

    \subsubsection{Ejemplos:}
    \begin{itemize}
        \item Tiempo constante ($O(1)$)
        \item Tiempo logarítmico ($O(\log n)$)
        \item Tiempo lineal ($O(n)$)
        \item Tiempo cuadrático ($O(n^2)$)
        \item Otras funciones polinomiales como $O(n^3)$ o $O(n^4)$.
    \end{itemize}

    \subsubsection{Eficiencia:}
    Los algoritmos de tiempo polinomial se consideran eficientes y escalables, lo que significa que pueden manejar entradas relativamente grandes sin una degradación significativa del rendimiento.

    \subsection{Complejidad de Tiempo Superpolinomial}

    \subsubsection{Definición:}
    Un algoritmo es de tiempo superpolinomial si su tiempo de ejecución no está acotado por ninguna función polinomial del tamaño de la entrada.

    \subsubsection{Ejemplos:}
    \begin{itemize}
        \item Tiempo exponencial ($O(2^n)$)
        \item Tiempo factorial ($O(n!)$)
        \item Cualquier complejidad temporal que crezca más rápido que una función polinomial.
    \end{itemize}

    \subsubsection{Eficiencia:}
    Los algoritmos de tiempo superpolinomial se consideran generalmente ineficientes y pueden volverse impracticables incluso para tamaños de entrada moderados.

    \subsection{¿Por Qué Hacer esta Distinción?}
    La distinción entre complejidad de tiempo polinomial y superpolinomial es fundamental en el diseño y análisis de algoritmos porque:

    \subsubsection{Escalabilidad:}
    Los algoritmos de tiempo polinomial son escalables, lo que significa que su rendimiento no se degrada significativamente a medida que aumenta el tamaño de la entrada.

    \subsubsection{Practicidad:}
    Los algoritmos de tiempo superpolinomial pueden volverse intratables computacionalmente incluso para tamaños de entrada relativamente pequeños, lo que los hace poco prácticos para aplicaciones del mundo real.

    \subsubsection{Clases de Complejidad:}
    Clases de complejidad como P (tiempo polinomial) y NP (tiempo polinomial no determinista) se basan en esta distinción, destacando la importancia de esta separación en la teoría de la computación.

	\subsection{Ejemplos de Problemas Polinomiales y Superpolinomiales}

    \subsubsection{Problemas Polinomiales:}
    \begin{itemize}
        \item Búsqueda en un arreglo ($O(n)$)
        \item Ordenamiento de una lista ($O(n \log n)$)
        \item Encontrar el camino más corto en un grafo ($O(n^2)$)
    \end{itemize}

    \subsubsection{Problemas Superpolinomiales:}
    \begin{itemize}
        \item El Problema del Viajero (NP-difícil, sin solución polinomial conocida)
        \item Resolver un Sudoku (todos los algoritmos conocidos son superpolinomiales)
        \item Factorización de números grandes (sin solución polinomial conocida)
    \end{itemize}

	\section{Contenido Adicional}

    \subsection{Clase 16: Complejidad: P, NP, NP-completitud, Reducciones \cite{demaine2015complexity}}

    Video de la clase en  \href{https://www.youtube.com/watch?v=eHZifpgyH_4&t=66s}{YouTube} \\
    Video de la clase en  \href{https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/resources/lecture-16-complexity-p-np-np-completeness-reductions/}{MIT OpenCourseWare}

    \subsection{Resumen del Video}
    En esta clase sobre NP-completitud, Erik Demaine explica conceptos fundamentales sobre problemas de decisión y sus complejidades computacionales, enfocándose particularmente en la distinción entre \textbf{P} (problemas que se pueden resolver en tiempo polinomial) y \textbf{NP} (problemas que se pueden verificar en tiempo polinomial no determinista). Utiliza el problema \textbf{3SAT} como ejemplo, donde las variables y sus negaciones deben asignarse valores de verdad para satisfacer una fórmula.

    Demaine aclara los criterios para identificar problemas NP-completos: deben pertenecer a \textbf{NP} y ser también \textbf{NP-duros}, lo que indica que son al menos tan difíciles como todos los problemas en NP. Resalta la importancia de las reducciones en tiempo polinomial, que demuestran que resolver un problema puede llevar a la solución de otro, con la profunda implicación de que si existiera un algoritmo de tiempo polinomial para un problema NP-completo, esto podría significar que \textbf{P} es igual a \textbf{NP}, un tema de gran debate en teoría de la computación.

    Para ilustrar aún más la NP-completitud, Demaine creativamente conecta el problema 3SAT con el videojuego \textit{Super Mario Brothers}, construyendo mecánicas de juego que se asemejan a variables lógicas y cláusulas. Esto no solo ejemplifica aplicaciones del mundo real, sino que también involucra principios teóricos en contextos prácticos.

    La clase profundiza en conceptos NP-duros con ejemplos como el problema de \textbf{tres emparejamientos dimensionales (3DM)} y el problema de recolección de basura, además de resaltar otros problemas NP-completos, como el problema de la suma de subconjuntos, el problema de partición, el empaque de rectángulos y los rompecabezas generalizados. Cada concepto se aborda a través del lente de las reducciones, demostrando cómo están interconectados dentro del ámbito de la complejidad computacional.

    \subsection*{Puntos Destacados}
    \begin{itemize}
        \item \textbf{Problema 3SAT}: Problema NP-completo fundamental ilustrado a través de mecánicas de videojuegos.
        \item \textbf{Reducciones en Tiempo Polinomial}: Herramienta clave para demostrar NP-dureza y establecer relaciones entre problemas.
        \item \textbf{Discusión P vs. NP}: Implicación crucial de encontrar algoritmos de tiempo polinomial para problemas NP-completos.
        \item \textbf{Emparejamiento Tridimensional (3DM)}: Desafío avanzado en teoría de grafos que muestra la complejidad NP-dura.
        \item \textbf{Gadgets para Recolección de Basura}: Mecanismo innovador que asegura cobertura en reducciones.
        \item \textbf{Problemas de Suma de Subconjuntos y Partición}: Ejemplos clásicos de NP-completitud que ilustran relaciones intrincadas entre problemas computacionales.
        \item \textbf{Rompecabezas Generalizados}: Problema NP-completo que ilustra los desafíos en la transición entre problemas numéricos y no numéricos.
    \end{itemize}

    \subsection*{Puntos Clave}
    \begin{itemize}
        \item \textbf{Comprensión de NP y NP-Completo}: Demaine enfatiza la diferencia entre \textbf{P} y \textbf{NP}, crucial para entender los límites de la eficiencia algorítmica.
        \item \textbf{3SAT como Fundamento}: El problema 3SAT es fundamental para demostrar NP-completitud y sirve como una referencia crítica para reducciones a otros problemas NP.
        \item \textbf{Importancia de las Reducciones}: Las reducciones son esenciales en el diseño de algoritmos, ayudando a probar la NP-completitud al transformar efectivamente un problema en otro.
        \item \textbf{Aplicaciones Interactivas}: La aplicación de conceptos teóricos a escenarios prácticos, como la analogía con Super Mario Brothers, ilustra la interacción entre los principios algorítmicos y los videojuegos.
        \item \textbf{Examinando la Dureza en Varios Problemas}: La clase resalta las amplias implicaciones que estos problemas tienen en escenarios del mundo real.
        \item \textbf{Gadgets Innovadores}: El desarrollo de gadgets para crear representaciones específicas de variables y cláusulas destaca el aspecto creativo de la teoría computacional.
        \item \textbf{Direcciones Futuras}: Se anima a los investigadores a explorar nuevos marcos y metodologías para preguntas no resueltas en la complejidad computacional.
    \end{itemize}

    Descargar las notas de clase del Prof. Demaine desde \href{https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/resources/mit6_046js15_lec16/}{aquí}.


    \section{Lecturas Recomendadas}

    \begin{enumerate}
        \item Capítulo 34 de Cormen et, al \cite{cormen2022algorithms}.  Secciones: 34.1, 34.2, and 34.3.
        \item Capítulo 13 de Baase y Van Gelder \cite{baase2002algoritmos} (En Español).  Secciones: 13.1, 13.2, and 13.3.
    \end{enumerate}

    \bibliographystyle{plain}
    \bibliography{references}

\end{document}
